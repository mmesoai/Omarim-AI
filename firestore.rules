/**
 * @file Firestore Security Rules
 * @description This ruleset enforces a strict user-ownership model for most collections,
 *              with public read access for specific collections like inbound replies and domain checks.
 *              It leverages structural segregation and denormalization to ensure efficient
 *              and secure access control without complex queries.
 *
 * Data Structure:
 * - User-specific data is nested under `/users/{userId}`, reflecting a private data tree.
 * - Publicly readable data resides in top-level collections like `/domainChecks` and `/emails/{emailId}/inboundReplies`.
 *
 * Key Security Decisions:
 * - User data is strictly owned and managed by the individual user.
 * - Listing of users is disallowed to prevent information harvesting.
 * - Inbound replies and domain checks are publicly readable.
 * - Administrative access is required for provisioning and store-related collections.
 * - Relationships are enforced through denormalized fields within documents.
 *
 * Denormalization for Authorization:
 * - Leads: Contain a `notionPageId` to directly link them to their parent NotionPage, avoiding extra reads for authorization.
 * - Emails: Include `outreachSequenceId` and `leadId` for quick association with the sequence and lead they belong to.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Checks if the current user is signed in.
     * @return {boolean} True if the user is signed in, false otherwise.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * @description Checks if the current user is the owner of the resource.
     * @param {string} userId The user ID to check against.
     * @return {boolean} True if the user is the owner, false otherwise.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * @description Checks if the current user is the owner of the resource and the resource exists.
     *              This function is used for update and delete operations to ensure that the
     *              document exists before attempting to modify or delete it.
     * @param {string} userId The user ID to check against.
     * @return {boolean} True if the user is the owner and the resource exists, false otherwise.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    /**
     * @description Rule for user profiles.
     * @path /users/{userId}
     * @allow (create) User 'test_user' can create their own profile (request.auth.uid == userId).
     * @deny (create) User 'test_user' cannot create a profile for another user (request.auth.uid != userId).
     * @allow (get, update, delete) User 'test_user' can read, update, and delete their own profile (request.auth.uid == userId).
     * @deny (get, update, delete) User 'another_user' cannot read, update, or delete 'test_user's profile (request.auth.uid != userId).
     * @principle Enforces document ownership for writes, restricts access to a user's own data tree.
     */
    match /users/{userId} {
      allow create: if isOwner(userId) && request.resource.data.id == userId;
      allow get: if isOwner(userId);
      allow list: if false; // Listing users is not allowed
      allow update: if isExistingOwner(userId) && request.resource.data.id == resource.data.id;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Rule for Notion pages owned by a user.
     * @path /users/{userId}/notionPages/{notionPageId}
     * @allow (create) User 'test_user' can create a Notion page under their profile (request.auth.uid == userId).
     * @deny (create) User 'another_user' cannot create a Notion page under 'test_user's profile (request.auth.uid != userId).
     * @allow (get, list, update, delete) User 'test_user' can read, list, update, and delete their own Notion pages (request.auth.uid == userId).
     * @deny (get, list, update, delete) User 'another_user' cannot read, list, update, or delete 'test_user's Notion pages (request.auth.uid != userId).
     * @principle Enforces document ownership for writes, restricts access to a user's own data tree.
     */
    match /users/{userId}/notionPages/{notionPageId} {
      allow create: if isOwner(userId);
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Rule for leads associated with a Notion page owned by a user.
     * @path /users/{userId}/notionPages/{notionPageId}/leads/{leadId}
     * @allow (create) User 'test_user' can create a lead under their Notion page (request.auth.uid == userId).
     * @deny (create) User 'another_user' cannot create a lead under 'test_user's Notion page (request.auth.uid != userId).
     * @allow (get, list, update, delete) User 'test_user' can read, list, update, and delete leads under their Notion page (request.auth.uid == userId).
     * @deny (get, list, update, delete) User 'another_user' cannot read, list, update, or delete leads under 'test_user's Notion page (request.auth.uid != userId).
     * @principle Enforces document ownership for writes, restricts access to a user's own data tree.
     */
    match /users/{userId}/notionPages/{notionPageId}/leads/{leadId} {
      allow create: if isOwner(userId);
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Rule for outreach sequences created by a user.
     * @path /users/{userId}/outreachSequences/{outreachSequenceId}
     * @allow (create) User 'test_user' can create an outreach sequence under their profile (request.auth.uid == userId).
     * @deny (create) User 'another_user' cannot create an outreach sequence under 'test_user's profile (request.auth.uid != userId).
     * @allow (get, list, update, delete) User 'test_user' can read, list, update, and delete their own outreach sequences (request.auth.uid == userId).
     * @deny (get, list, update, delete) User 'another_user' cannot read, list, update, or delete 'test_user's outreach sequences (request.auth.uid != userId).
     * @principle Enforces document ownership for writes, restricts access to a user's own data tree.
     */
    match /users/{userId}/outreachSequences/{outreachSequenceId} {
      allow create: if isOwner(userId);
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Rule for emails associated with an outreach sequence owned by a user.
     * @path /users/{userId}/outreachSequences/{outreachSequenceId}/emails/{emailId}
     * @allow (create) User 'test_user' can create an email under their outreach sequence (request.auth.uid == userId).
     * @deny (create) User 'another_user' cannot create an email under 'test_user's outreach sequence (request.auth.uid != userId).
     * @allow (get, list, update, delete) User 'test_user' can read, list, update, and delete emails under their outreach sequence (request.auth.uid == userId).
     * @deny (get, list, update, delete) User 'another_user' cannot read, list, update, or delete emails under 'test_user's outreach sequence (request.auth.uid != userId).
     * @principle Enforces document ownership for writes, restricts access to a user's own data tree.
     */
    match /users/{userId}/outreachSequences/{outreachSequenceId}/emails/{emailId} {
      allow create: if isOwner(userId);
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Rule for inbound replies associated with a specific email. Public Read.
     * @path /emails/{emailId}/inboundReplies/{inboundReplyId}
     * @allow (get, list) Any user can read inbound replies.
     * @deny (create, update, delete) No one can create, update, or delete inbound replies.
     * @principle Allows public read access, restricts write access.
     */
    match /emails/{emailId}/inboundReplies/{inboundReplyId} {
      allow get: if true;
      allow list: if true;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Rule for domain check results. Public Read.
     * @path /domainChecks/{domainCheckId}
     * @allow (get, list) Any user can read domain check results.
     * @deny (create, update, delete) No one can create, update, or delete domain check results.
     * @principle Allows public read access, restricts write access.
     */
    match /domainChecks/{domainCheckId} {
      allow get: if true;
      allow list: if true;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Rule for payments made by a user.
     * @path /users/{userId}/payments/{paymentId}
     * @allow (create) User 'test_user' can create a payment record under their profile (request.auth.uid == userId).
     * @deny (create) User 'another_user' cannot create a payment record under 'test_user's profile (request.auth.uid != userId).
     * @allow (get, list, update, delete) User 'test_user' can read, list, update, and delete their own payment records (request.auth.uid == userId).
     * @deny (get, list, update, delete) User 'another_user' cannot read, list, update, or delete 'test_user's payment records (request.auth.uid != userId).
     * @principle Enforces document ownership for writes, restricts access to a user's own data tree.
     */
    match /users/{userId}/payments/{paymentId} {
      allow create: if isOwner(userId);
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Rule for provisioning records. Limited to Admin access.
     * @path /provisioning/{provisioningId}
     * @allow (get, list, create, update, delete) Only admin can create, read, update, or delete provisioning records.
     * @principle Restricts access to administrative users.
     */
    match /provisioning/{provisioningId} {
      // TODO: Implement admin role check.
      allow get: if false; // TODO: Add admin role check
      allow list: if false; // TODO: Add admin role check
      allow create: if false; // TODO: Add admin role check
      allow update: if false; // TODO: Add admin role check
      allow delete: if false; // TODO: Add admin role check
    }

    /**
     * @description Rule for store integrations. Limited to Admin access.
     * @path /stores/{storeId}
     * @allow (get, list, create, update, delete) Only admin can create, read, update, or delete store integrations.
     * @principle Restricts access to administrative users.
     */
    match /stores/{storeId} {
      // TODO: Implement admin role check.
      allow get: if false; // TODO: Add admin role check
      allow list: if false; // TODO: Add admin role check
      allow create: if false; // TODO: Add admin role check
      allow update: if false; // TODO: Add admin role check
      allow delete: if false; // TODO: Add admin role check
    }

    /**
     * @description Rule for products belonging to a store. Limited to Admin Access.
     * @path /stores/{storeId}/products/{productId}
     * @allow (get, list, create, update, delete) Only admin can create, read, update, or delete products.
     * @principle Restricts access to administrative users.
     */
    match /stores/{storeId}/products/{productId} {
      // TODO: Implement admin role check.
      allow get: if false; // TODO: Add admin role check
      allow list: if false; // TODO: Add admin role check
      allow create: if false; // TODO: Add admin role check
      allow update: if false; // TODO: Add admin role check
      allow delete: if false; // TODO: Add admin role check
    }
  }
}